"""Module for running the flask application."""

import sys
import os
from decouple import config, Csv
from flask_cors import CORS
from flask_wtf import CSRFProtect
from controllers.db_controller import BaseController
from openapi_server import encoder
from controllers.models.tag_term_model import Terms
from controllers.management.admin import YesManModel, AiAdminModel
from controllers.management.email.email_scheduler import EmailScheduler


if not os.path.exists(".env"):
    print(".env file not found.You may create one from 'sample-env.txt'.")
    sys.exit(1)

OPENAPI_STUB_DIR = config("OPENAPI_STUB_DIR", default="swagger_server")

if not os.path.exists(OPENAPI_STUB_DIR):
    print(
        f"Folder '{OPENAPI_STUB_DIR}' not found.  "
        "Please create the folder and extract zip file "
        "generated by openapi-generator into it."
    )
    sys.exit(1)

sys.path.append(OPENAPI_STUB_DIR)

try:
    import connexion
except ModuleNotFoundError:
    print(
        "Please install all required packages by running:"
        " pip install -r requirements.txt"
    )
    sys.exit(1)


def create_app(engine=None, admin=None):
    """
    Setups and configure the application.

    Args:
        engine: Optional database engine to use. If None, a new engine will be created.
        admin: Optional admin model to use for validation.

    Returns: A configured connexion app.
    """
    app = connexion.App(__name__, specification_dir="./openapi/")
    app.app.json_encoder = encoder.JSONEncoder
    app.add_api(
        "ku-seek-api.yml",
        arguments={"title": "KU SEEK API"},
        pythonic_params=True,
    )
    # setup CORS Allowed origins
    CORS(
        app.app,
        resources={
            r"/*": {
                "origins": config(
                    "ALLOWED_ORIGINS", cast=Csv(), default="http://localhost:5173"
                )
            }
        },
        supports_credentials=True,
    )
    # setup CSRF
    app.app.secret_key = config("SECRET_KEY", default="very-secure-secret-key")
    CSRFProtect(app.app)

    # Setup database controller
    if engine:
        app.app.config["Database"] = engine
    else:
        app.app.config["Database"] = BaseController()

    # set up response headers
    @app.app.after_request
    def add_security_headers(resp):
        """Set security headers."""
        resp.headers['Content-Security-Policy']='default-src \'self\''
        resp.headers['X-Frame-Options']="DENY"
        resp.headers['X-Content-Type-Options']='nosniff'
        return resp

    # One-time (idempotent) seeding of common Terms into the database.
    # This runs on app start and will only insert missing terms.
    terms_list = [
        "React",
        "Vue",
        "Angular",
        "Node.js",
        "Python",
        "Django",
        "Machine Learning",
        "AWS",
        "SQL",
    ]

    try:
        with app.app.app_context():
            db = app.app.config.get("Database")
            if db and hasattr(db, "get_session"):
                session = db.get_session()
                added = 0
                try:
                    for name in terms_list:
                        exists = session.query(Terms).filter(Terms.name == name).first()
                        if exists:
                            continue
                        term = Terms(name=name, type="skill")
                        session.add(term)
                        added += 1
                    if added:
                        session.commit()
                except Exception:
                    session.rollback()
                    raise
                finally:
                    session.close()
    except Exception:
        print("Warning: failed to seed Terms table")
    app.app.config["Admin"] = YesManModel()
    # set an agentic model for validation if provided
    if admin:
        app.app.config["Admin"] = admin

    return app


prompt = os.path.join(
    os.getcwd(), "controllers", "management", "prompts", "validator_prompt.txt"
)
app = create_app(admin=AiAdminModel(prompt_file=prompt, model="gemini-2.0-flash"))

if __name__ == "__main__":
    try:
        # Setup email scheduler
        email_interval = config("EMAIL_SCHEDULER_INTERVAL", cast=int, default=300)
        email_scheduler = EmailScheduler(
            database=BaseController(), interval_seconds=email_interval
        )
        email_scheduler.start()
        # Start the app
        app.run(port=8000, debug=True, use_reloader=False)
    finally:
        email_scheduler.stop()
